<html>
	<head>
		<title>Bresenham's line algorithm</title>
		<link rel="stylesheet" type="text/css" href="../style/style.css" />
		<link rel="alternate" hreflang="fr" href="http://fredericgoset.ovh/mathematiques/courbes/fr/bresenham_line.html" />
	</head>

	<body>
		<div id="banner1">
		</div>
		<div id="menu">
			<ul>
				<li><a href="http://fredericgoset.ovh/index_en.html">Home</a></li>
				<li><a href="http://fredericgoset.ovh/mathematiques/courbes/en/index.html">Curves</a></li>
				<li><a href="mailto:fgoset@wanadoo.fr">Contact</a></li>
			</ul>
		</div>
		<div id="banner2">
		</div>
	
		<div id="titre">
			<p>
				Bresenham's line algorithm
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>About the code</p>
				</div>
				The code in this article was written using Code::Blocks and SDL 2.<br/>
				You can read <a href="http://fredericgoset.ovh/sdl/en/installation.html">here</a> a guide to install this sofware.<br/>
				Although it is based on SDL, I don't use its functions directly. I have written a small library with a few basic<br/>
				functions to ease the understanding and the portability to another language.<br/>
				You can read more about this lib <a href="http://fredericgoset.ovh/sdl/en/my_sdl_lib.html">here</a>.
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>A simple line</p>
				</div>
				How does your computer draw a line on the screen ?<br/>
				It's fairly easy to understand for an horizontal or vertical line, but what about a line of any slope that you<br/>
				would draw in a painting software ?<br/>
				Let's look at this diagram.<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line1.png"/>
				</div>
				<br/>
				It shows the pixels we have to draw if we want to represent the ideal line in green.<br/>
				We can notice that only 1 pixel is lit for every x coordinate. That is the nearest one to the ideal line.<br/>
				<br/>
				To simplify the explanations, from now on we will only talk about the lines like the one on this diagram that<br/>
				follow these constraints:<br/>
				<ul>
					<li><b>x1 &gt; x0</b> : x increases.</li>
					<li><b>y1 &gt; y0</b> : y increases.</li>
					<li><b>(x1 - x0) &gt; (y1 - y0)</b> : the line is more horizontal than vertical.</li>
				</ul>
				We will talk about the other cases at the end once we have well defined the algorithm for this one.<br/>
				<br/>
				Now how to find the equation to draw this line ?<br/>
				Let's remember an equation that each of you should know:
				<code><pre>
		y = m * x + b
				</pre></code>
				m is easy to understand. It's the slope of the line - the amount of increase in y divided by the amount of increase<br/>
				in x.<br/>
				In our case:
				<code><pre>
		m = (y1 - y0) / (x1 - x0)
				</pre></code>
				I don't want to compute b, so let's rework a little bit our equation. We had:
				<code><pre>
		y = m * x + b
				</pre></code>
				In particular, our first point (x0, y0) belong to this line so it also follow this equation:
				<code><pre>
		y0 = m * x0 + b
				</pre></code>
				Now if we substract this last equation from the previous one, we get:
				<code><pre>
		y - y0 = m * (x - x0) + b - b
				</pre></code>
				And b disappears. So after a little rewriting, we get a new formula for our line:
				<code><pre>
		y = m * (x - x0) + y0
				</pre></code>
				The simplest code to draw our line should then look like that:
				<code><pre>
		// line coordinates
		int x0 = 0;
		int y0 = 0;
		int x1 = 30;
		int y1 = 10;

		float slope = (float)(y1 - y0) / (float)(x1 - x0);

		for (int x = x0; x <= x1; ++x)
		{
			float y = slope * (x - x0) + y0;
			gfx.setPixel(x, y, Color(255, 255, 255));
		}
		gfx.render();
		
		<a href="../files/bresenham_line_src.zip">Download source code</a>
		<a href="../files/bresenham_line_exe.zip">Download executable for Windows</a>
				</pre></code>
				Here is the result:<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line2.png"/>
				</div>
				<br/>
				This line looks nice but there is a little something wrong with it.<br/>
				If you look at the first and the last horizontal segments, they should be balanced.<br/>
				This is only a rounding problem. That would be easy to fix, but let's put that aside as we will address this<br/>
				problem later in another way.<br/>
				<br/>
				So we have a drawing routine that works. Now what's the point of the Bresenham's algorithm ?<br/>
				Will it draw a nicer line ?<br/>
				Well, not really.<br/>
				<br/>
				Bresenham was a guy who worked for IBM. He wrote this algorithm in 1962.<br/>
				At this time computers were very slow so everything had to be optimized.<br/>
				<br/>
				In fact his algorithm is just a very optimized version of the one we just wrote.<br/>
				Lots of people nowadays say that optimizing is not useful because computers are far more efficient.<br/>
				So is it really worth the effort ? Well, we'll check that ourselves later.<br/>
				Anyways it's a good exercise to understand optimisation and how a processor works.<br/>
				So let's look at that step by step.
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>How to make it faster ?</p>
				</div>
				Before answering this question, let's ask ourselves what makes this code slow ?<br/>
				Let's look at the code again:
				<code><pre>
		// line coordinates
		int x0 = 0;
		int y0 = 0;
		int x1 = 30;
		int y1 = 10;

		float slope = (float)(y1 - y0) / (float)(x1 - x0);

		for (int x = x0; x <= x1; ++x)
		{
			float y = slope * (x - x0) + y0;
			gfx.setPixel(x, y, Color(255, 255, 255));
		}
				</pre></code>
				Note: I omitted the gfx.render() function because it is not part of the algorithm itself, it is only called at the<br/>
				end to display the result on the screen.<br/>
				<br/>
				So what can we see in this code ? There is:<br/>
				<ul>
					<li>A loop</li>
					<li>Some integer values</li>
					<li>Some floating point values</li>
					<li>Calculations on these values: additions, substractions, multiplications, and divisions</li>
					<li>A call to the function gfx.setPixel</li>
				</ul>
				Here are a few important rules that we can give about all the elements that we listed.<br/>
				<br/>
				When you have a loop everything inside of the loop is executed more times than if it was outside of the loop.<br/>
				In some programs this can be many more times...<br/>
				In our code, the loop is executed 21 times. That's the reason why we compute the slope outside of the loop.<br/>
				Because, as it is a constant value, there is no need to compute it 20 times...<br/>
				<br/>
				Integers are faster than floating points. Even if nowadays each procesor has a built in floating point coprocessor,<br/>
				intergers calculations are always faster than floting points ones.<br/>
				Furthermore, when you use floating points there is often a moment when you have to convert them to/from integers.<br/>
				<br/>
				With integers, additions and substractions are faster than multiplications and divisions.<br/>
				Well, that was true in 1962, but now it's only partially true.<br/>
				Divisions are always slower (unless it's by a power of 2), but modern processors use algorithms that makes<br/>
				multiplications as fast as additions.<br/>
				Anyway we will consider that we are still in 1962 because I want to explain the original algorithm.<br/>
				With floating points, multiplication is slower than addition on most of modern processors.<br/>
				<br/>
				Always be careful with functions that you didn't code yourself.<br/>
				Is gfx.setPixel() fast ? Does it take the same time when you call it twice with the same parameters ?<br/>
				Well, as I coded it myself, I can tell you that it is perhabs not the most efficient function for this<br/>
				particular algorithm but it should be fast enough.<br/>
				Anyway we won't recode it as it is not the purpose of this article.<br/>
				The important point is that even if we optimise everything in the algorithm, it will always be called one time for<br/>
				each pixel of the line. So it's total time of execution won't change.<br/>
				<br/>
				So now, let's see the optimisations that Bresenham did one after the other.
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>Removing the multiplication</p>
				</div>
				Look at the formula inside the loop:
				<code><pre>
		float y = slope * (x - x0) + y0;
				</pre></code>
				How does y change while x goes from x0 to x1 ?<br/>
				<br/>
				At the beginning, when x = x0, (x - x0) cancels out and y starts at y0.<br/>
				<br/>
				Then every time x is increased by 1, y is increased by slope.<br/>
				<br/>
				So we can rewrite our loop:
				<br/>
				<code><pre>
		float slope = (float)(y1 - y0) / (float)(x1 - x0);
		float y = y0;

		for (int x = x0; x <= x1; ++x)
		{
			gfx.setPixel(x, y, Color(255, 255, 255));
			y += slope;
		}
		gfx.render();
		
		<a href="../files/bresenham_line2_src.zip">Download source code</a>
		<a href="../files/bresenham_line2_exe.zip">Download executable for Windows</a>
				</pre></code>
				That's a great improvement. There is a lot less calculation inside the loop.<br/>
				There is only one addition left !<br/>
				<br/>
				Now let's look at the result:<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line3.png"/>
				</div>
				<br/>
				Well, there is still something wrong with this line.<br/>
				It turns out that it's a rounding error like for the first one.<br/>
				But you can ask yourself where is the rounding when you use only floating point values ?<br/>
				That's one of the awkward thing when using C or C++: it does hidden things.<br/>
				<br/>
				Our variable y is a float. The only calculation we do on it is an addition with another float variable, so it<br/>
				stays a float.<br/>
				But the setPixel() function takes ints as parameters. So the C compiler implicitely converts our float y to an int.<br/>
				And when it does so, it always take the least integer.<br/>
				If our y has a value of say 5.7, the conversion to an int will give 5.<br/>
				But we saw at the beginning that we should take the nearest interger to get the pixel that is the closest to the<br/>
				ideal line.<br/>
				<br/>
				So we really need to fix this rounding problem. And the way to do it is probably the most interesting part of the<br/>
				Bresenham's algorithm.
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>Fixing the rounding</p>
				</div>
				As we said, each time x is increased by one, y is increased by slope.<br/>
				y must be a float value because the slope is a float.<br/>
				But in the end, we draw a pixel whose coordinates are integers.<br/>
				So let's separate these values. On one side we will have an integer y that represents the true coordinate of the<br/>
				current pixel.<br/>
				And on the other side we will have a float value that stores the sum of the slopes - the remainder.<br/>
				Let's look in detail what is happening on this zoomed image.<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line4.png"/>
				</div>
				<br/>
				Here we have the same slope as in our code: 10/30 = 1/3.<br/>
				Notice that the ideal line we want to draw begins at the center of the first pixel.<br/>
				<br/>
				For the first pixel the value of y is y0 and we draw the the pixel at y0.<br/>
				For the second pixel the value of y is now y0 + 0.333... and we still draw the pixel at y0.<br/>
				For the third pixel the value of y is y0 + 0.666... and we draw the pixel at (y0 + 1).<br/>
				Notice that we change the coordinate of the pixel we draw because the floating point value exceeds 0.5.<br/>
				<br/>
				Now let's name the variables to make things clearer.<br/>
				<ul>
					<li>Let's name oldY the floating point y that we used so far</li>
					<li>The new integer y will be called simply y...</li>
					<li>The remainder floating value will be called "error" to follow the names used in most articles that explain<br/>
					this algorithm</li>
				</ul>
				So we have this relation:<br/>
				<code><pre>
		oldY = y + error
				</pre></code>
				Now let's recapitulate our algorithm:<br/>
				We start by setting y = y0 and error = 0<br/>
				At each step:<br/>
				<ul>
					<li>We add slope to error</li>
					<li>If error is greater than 0.5, we add 1 to y</li>
				</ul>
				But to follow oldy = y + error, if we increase y by 1, we must also substract 1 from error.<br/>
				<br/>
				That leads to this code:
				<code><pre>
		float slope = (float)(y1 - y0) / (float)(x1 - x0);
		int y = y0;
		float error = 0.0;

		for (int x = x0; x <= x1; ++x)
		{
			gfx.setPixel(x, y, Color(255, 255, 255));
			error += slope;

			if (error >= 0.5)
			{
				y++;
				error -= 1.0;
			}
		}
		gfx.render();

		<a href="../files/bresenham_line3_src.zip">Download source code</a>
		<a href="../files/bresenham_line3_exe.zip">Download executable for Windows</a>
				</pre></code>
				And this is what we get:<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line5.png"/>
				</div>
				<br/>
				The fact that we compare error with 0.5 fixed our rounding problem.<br/>
				If you take a screenshot of the program, load it in the Gimp and draw a line of another color above it you will<br/>
				see that you get exactly the same pixels. Because the Gimp like most graphical softwares use the Bresenham<br/>
				algorithm too.
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>Removing the floats</p>
				</div>
				Let's go on with our optimisations.<br/>
				First we will offset the error.<br/>
				error starts at 0.0 then we compare it with 0.5.<br/>
				It would be exactly the same if we made is start at -0.5 then compare it with 0.0.<br/>
				Comparing a value with 0 is a little bit faster than comparing it with a constant. It will be particularly true when we<br/>
				have it converted to an integer.<br/>
				So our code becomes:<br/>
				<code><pre>
		int y = y0;

		float slope = (float)(y1 - y0) / (float)(x1 - x0);
		float error = -0.5;

		for (int x = x0; x <= x1; ++x)
		{
			gfx.setPixel(x, y, Color(255, 255, 255));
			error += slope;

			if (error >= 0.0)
			{
				y++;
				error -= 1.0;
			}
		}
		gfx.render();

		<a href="../files/bresenham_line4_src.zip">Download source code</a>
		<a href="../files/bresenham_line4_exe.zip">Download executable for Windows</a>
				</pre></code>
				Now we will do a little renaming job as it will be clearer for the next stage.<br/>
				We'll name "dx" the value (x1 - x0).<br/>
				We'll name "dy" the value (y1 - y0).<br/>
				And finally we'll name errorInc the value we add to error when y changes, that's to say -1.0.<br/>
				<code><pre>
		int y = y0;

		int dx = x1 - x0;
		int dy = y1 - y0;
		float slope = (float)dy / (float)dx;
		float error = -0.5;
		float errorInc = -1.0;

		for (int x = x0; x <= x1; ++x)
		{
			gfx.setPixel(x, y, Color(255, 255, 255));
			error += slope;

			if (error >= 0.0)
			{
				y++;
				error += errorInc;
			}
		}
		gfx.render();

		<a href="../files/bresenham_line5_src.zip">Download source code</a>
		<a href="../files/bresenham_line5_exe.zip">Download executable for Windows</a>
				</pre></code>
				Now we will convert the floating point values to integers.<br/>
				The only floating point variables that we have are the ones that are used for the calculation of error: slope,<br/>
				error and errorInc.<br/>
				To avoid loosing precision the idea is to multiply these variables by a quantity that make them all integers.<br/>
				<br/>
				slope is dy/dx so we must multiply it at least by dx to make it integer.<br/>
				error start at -0.5 so we have to multiply it at least by 2.<br/>
				Finally, if we multiply all these variables by 2*dx they will all become integers.
				<code><pre>
		int y = y0;

		int dx = x1 - x0;
		int dy = y1 - y0;
		int slope = 2 * dy;
		int error = -dx;
		int errorInc = -2 * dx;

		for (int x = x0; x <= x1; ++x)
		{
			gfx.setPixel(x, y, Color(255, 255, 255));
			error += slope;

			if (error >= 0)
			{
				y++;
				error += errorInc;
			}
		}
		gfx.render();
		
		<a href="../files/bresenham_line6_src.zip">Download source code</a>
		<a href="../files/bresenham_line6_exe.zip">Download executable for Windows</a>
				</pre></code>
				<br/>
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>Was it worth the effort ?</p>
				</div>
				Now we did everything we could to optimize the code.<br/>
				At this point, articles that explain the Bresenham's algorithm generally try to reduce the number of variables or<br/>
				to invert the sign of error and errorInc.<br/>
				These are only aesthetic changes that does not improve the speed of the code.<br/>
				<br/>
				So now we will try to see if all these optimisations really improved the speed of the code.<br/>
				The SDL library has a high accuracy timer that is meant just for this kind of tasks.<br/>
				I added 2 functions to my lib in the System module:
				<code><pre>
		void    StartPerfCounter();
		float   StopPerfCounter();
				</pre></code>
				You just call StartPerfCounter() at the beginning of the function you want to time, and StopPerfCounter() at the<br/>
				end.<br/>
				StopPerfCounter() returns a float that is the number of milliseconds elapsed between the two calls.
				<br/>
				I used these functions to time on one side the first routine we wrote at the beginning and on the other side the<br/>
				last one we wrote.<br/>
				To get more precision I draw a bunch of lines spreading through the width of the window and following the<br/>
				constraints we defined at the beginning.<br/>
				Here is the full code of this test:
				<code><pre>
		#include &lt;stdio.h&gt;
		#include &lt;stdlib.h&gt;
		#include &lt;math.h&gt;
		#include "main.h"
		#include "Graphics.h"
		#include "System.h"

		#define SCREEN_WIDTH    640
		#define SCREEN_HEIGHT   480

		void drawLineSlow(int x0, int y0, int x1, int y1, Color c)
		{
			float slope = (float)(y1 - y0) / (float)(x1 - x0);

			for (int x = x0; x &lt;= x1; ++x)
			{
				float y = slope * (x - x0) + y0;
				gfx.setPixel(x, y, c);
			}
		}

		void drawLine(int x0, int y0, int x1, int y1, Color c)
		{
			int y = y0;

			int dx = x1 - x0;
			int dy = y1 - y0;
			int slope = 2 * dy;
			int error = -dx;
			int errorInc = -2 * dx;

			for (int x = x0; x &lt;= x1; ++x)
			{
				gfx.setPixel(x, y, c);
				error += slope;

				if (error &gt;= 0)
				{
					y++;
					error += errorInc;
				}
			}
		}

		int main(int argc, char* argv[])
		{
			// init the window
			gfx.init("Bresenham Line 7", SCREEN_WIDTH, SCREEN_HEIGHT);
			gfx.init2D();

			// test the slow function
			gfx.clearScreen(Color(0, 0, 0, SDL_ALPHA_OPAQUE));
			sys.StartPerfCounter();

			for (int i = 10; i < SCREEN_WIDTH; ++i)
				drawLineSlow(0, 0, i, 10, Color(i & 0xff, 255, 0));

			float time1 = sys.StopPerfCounter();
			printf("time1: %f ms\n", time1);

			// test the fast function
			gfx.clearScreen(Color(0, 0, 0, SDL_ALPHA_OPAQUE));
			sys.StartPerfCounter();

			for (int i = 10; i < SCREEN_WIDTH; ++i)
				drawLine(0, 0, i, 10, Color(i & 0xff, 255, 0));

			float time2 = sys.StopPerfCounter();
			printf("time2: %f ms\n", time2);

			gfx.render();

			while (sys.isQuitRequested() == false)
			{
				sys.processEvents();
			}

			gfx.quit();

			return EXIT_SUCCESS;
		}
		
		<a href="../files/bresenham_line7_src.zip">Download source code</a>
		<a href="../files/bresenham_line7_exe.zip">Download executable for Windows</a>
				</pre></code>
				Runing it 3 times on my computer that has an Intel Core i3-4330, I get an average of 0.938 ms for the first<br/>
				routine and 0.514 ms for the optimised one.<br/>
				So even on a modern processor with the optimisations of the compiler we wrote a code that is about 2 times faster.<br/>
				That's not bad at all.<br/>
				And remember that this time include the execution time of setPixel() that we did not optimise.
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>Generalizing the algorithm</p>
				</div>
				If we use our optimised code to draw a line that is nearly vertical. Like.
				<code><pre>
		int x0 = 0;
		int y0 = 0;
		int x1 = 10;
		int y1 = 30;
				</pre></code>
				We get a 45 degrees line:<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line6.png"/>
				</div>
				<br/>
				With the first function we wrote we get another result.<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line7.png"/>
				</div>
				<br/>
				Some pixels are missing.<br/>
				It is easy to understand as our function only draws 1 pixel for each x coordinate.<br/>
				With lines that are more vertical we should loop through y instead of x.<br/>
				<br/>
				Now remember the constraints we set up at the beginning:
				<ul>
					<li><b>x1 &gt; x0</b> : x increases.</li>
					<li><b>y1 &gt; y0</b> : y increases.</li>
					<li><b>(x1 - x0) &gt; (y1 - y0)</b> : the line is more horizontal than vertical.</li>
				</ul>
				We can divide the screen plane into 8 "octants".<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line8.png"/>
				</div>
				<br/>
				The constraints above limit us to octant 0.<br/>
				Now generally when we get here the other articles simply write a seperate function for each octant and 2 other<br/>
				cases for perfectly horizontal and vertical lines.
				This is in the spirit of the algorithm to get the fastest code.<br/>
				But I prefer a more compact code even if it is a litle bit slower. It will be far easier if we have to modify<br/>
				this code in the future.<br/>
				<br/>
				Let's look at the octants 0, 3, 4 and 7, these are all the cases where the line is more horizontal than vertical.<br/>
				For all these cases we will keep the loop trough the x coordinates. But the direction can change: x1 can be less<br/>
				than x0 or y1 can be less than y0.<br/>
				<br/>
				We will introduce 2 mathematical macros.<br/>
				ABS returns the absolute value of a number.<br/>
				<code><pre>
		#define ABS(_x) ((_x) >= 0 ? (_x) : -(_x))
				</pre></code>
				SGN returns the sign of a value: either -1, 1 or 0 if the number is negative, positive or null.<br/>
				<code><pre>
		#define SGN(_x) ((_x) < 0 ? -1 : \
		                 ((_x) > 0 ? 1 : 0))
				</pre></code>
				Now we will use 2 increment variables for x and y to handle all the cases.
				<code><pre>
		void drawLine(int x0, int y0, int x1, int y1, Color c)
		{
			int y = y0;

			int dx = x1 - x0;
			int dy = y1 - y0;
			int incX = SGN(dx);
			int incY = SGN(dy);
			int slope = 2 * ABS(dy);
			int error = -ABS(dx);
			int errorInc = -2 * ABS(dx);

			for (int x = x0; x != x1 + incX; x += incX)
			{
				gfx.setPixel(x, y, c);
				error += slope;

				if (error >= 0)
				{
					y += incY;
					error += errorInc;
				}
			}
		}

		<a href="../files/bresenham_line8_src.zip">Download source code</a>
		<a href="../files/bresenham_line8_exe.zip">Download executable for Windows</a>
				</pre></code>
				Now it's easy to write all the cases. The vertical ones are just symetrical.
				<code><pre>
		#define ABS(_x) ((_x) >= 0 ? (_x) : -(_x))
		#define SGN(_x) ((_x) < 0 ? -1 : \
						 ((_x) > 0 ? 1 : 0))

		void drawLine(int x0, int y0, int x1, int y1, Color c)
		{
			int dx = x1 - x0;
			int dy = y1 - y0;
			int incX = SGN(dx);
			int incY = SGN(dy);
			dx = ABS(dx);
			dy = ABS(dy);

			if (dy == 0)
			{
				// horizontal line
				for (int x = x0; x != x1 + incX; x += incX)
					gfx.setPixel(x, y0, c);
			}
			else if (dx == 0)
			{
				// vertical line
				for (int y = y0; y != y1 + incY; y += incY)
					gfx.setPixel(x0, y, c);
			}
			else if (dx >= dy)
			{
				// more horizontal than vertical
				int slope = 2 * dy;
				int error = -dx;
				int errorInc = -2 * dx;
				int y = y0;

				for (int x = x0; x != x1 + incX; x += incX)
				{
					gfx.setPixel(x, y, c);
					error += slope;

					if (error >= 0)
					{
						y += incY;
						error += errorInc;
					}
				}
			}
			else
			{
				// more vertical than horizontal
				int slope = 2 * dx;
				int error = -dy;
				int errorInc = -2 * dy;
				int x = x0;

				for (int y = y0; y != y1 + incY; y += incY)
				{
					gfx.setPixel(x, y, c);
					error += slope;

					if (error >= 0)
					{
						x += incX;
						error += errorInc;
					}
				}
			}
		}

		<a href="../files/bresenham_line9_src.zip">Download source code</a>
		<a href="../files/bresenham_line9_exe.zip">Download executable for Windows</a>
				</pre></code>
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>Testing</p>
				</div>
				Finally, I put this line routine in Graphics and wrote a kind of screensaver to test the lines in any orientations.<br/>
				<br/>
				<div id="image">
					<img src="images/bresenham_line9.png"/>
				</div>
				<br/>
				<code><pre>
		#include &lt;stdio.h&gt;
		#include &lt;stdlib.h&gt;
		#include &lt;math.h&gt;
		#include &lt;time.h&gt;
		#include "main.h"
		#include "Graphics.h"
		#include "System.h"

		#define SCREEN_WIDTH    640
		#define SCREEN_HEIGHT   480

		int main(int argc, char* argv[])
		{
			// init the window
			gfx.init("Bresenham Line 10", SCREEN_WIDTH, SCREEN_HEIGHT);
			gfx.init2D();
			gfx.clearScreen(Color(0, 0, 0, SDL_ALPHA_OPAQUE));

			srand(time(NULL));

			int x0 = rand() % SCREEN_WIDTH;
			int y0 = rand() % SCREEN_HEIGHT;
			int spdX0 = (rand() % 7) - 3;
			int spdY0 = (rand() % 7) - 3;

			int x1 = rand() % SCREEN_WIDTH;
			int y1 = rand() % SCREEN_HEIGHT;
			int spdX1 = (rand() % 7) - 3;
			int spdY1 = (rand() % 7) - 3;

			int r = rand() % 256;
			int g = rand() % 256;
			int b = rand() % 256;
			int spdR = (rand() % 7) - 3;
			int spdG = (rand() % 7) - 3;
			int spdB = (rand() % 7) - 3;

			while (sys.isQuitRequested() == false)
			{
				gfx.line(x0, y0, x1, y1, Color(r, g, b));

				x0 += spdX0;
				if (x0 &lt; 0 || x0 &gt;= SCREEN_WIDTH)
				{
					spdX0 = -spdX0;
					x0 += spdX0;
				}

				y0 += spdY0;
				if (y0 &lt; 0 || y0 &gt;= SCREEN_HEIGHT)
				{
					spdY0 = -spdY0;
					y0 += spdY0;
				}

				x1 += spdX1;
				if (x1 &lt; 0 || x1 &gt;= SCREEN_WIDTH)
				{
					spdX1 = -spdX1;
					x1 += spdX1;
				}

				y1 += spdY1;
				if (y1 &lt; 0 || y1 &gt;= SCREEN_HEIGHT)
				{
					spdY1 = -spdY1;
					y1 += spdY1;
				}

				r += spdR;
				if (r &lt; 0 || r &gt; 255)
				{
					spdR = -spdR;
					r += spdR;
				}

				g += spdG;
				if (g &lt; 0 || g &gt; 255)
				{
					spdG = -spdG;
					g += spdG;
				}

				b += spdB;
				if (b &lt; 0 || b &gt; 255)
				{
					spdB = -spdB;
					b += spdB;
				}

				gfx.render();
				sys.wait(10);
				sys.processEvents();
			}

			gfx.quit();

			return EXIT_SUCCESS;
		}

		<a href="../files/bresenham_line10_src.zip">Download source code</a>
		<a href="../files/bresenham_line10_exe.zip">Download executable for Windows</a>
				</pre></code>
			</p>
		</div>

		<div id="contenuprincipal">
			<p>
				<div id="soustitre">
					<p>Links</p>
				</div>
				<a href="https://youtu.be/Ipg3IrFNmZ8">Video of the last program</a>
			</p>
		</div>

		<div id="footer">
			<p>Fr&eacute;d&eacute;ric Goset 2018</p>
		</div>
	</body>
</html>